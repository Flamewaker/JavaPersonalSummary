# 刷题规划
1. 做到手撕代码的能力。
2. 做到举一反三的能力。
3. 养成良好的编程习惯。先规划好大致框架，再想好边界条件和特殊用例，最后进行编码。
## 高频面试题
- [x] 剑指Offer

- [x] 1 两数之和

- [x] 3 无重复字符的最长子串 

- [x] 5 最长回文子串

- [x] 15 三数之和 (*)

- [ ] 14 最长公共前缀

- [x] 31 下一个排列

- [x] 42 接雨水(*)

- [x] 46 全排列

- [x] 47 全排列2

- [x] 50 Pow(x, n) 

- [x] 69 x 的平方根

- [x] 70 爬楼梯

- [x] 121 买卖股票的最佳时机  

- [x] 122 买卖股票的最佳时机 II

- [x] 101 对称二叉树

- [x] 102 二叉树的层序遍历

- [x] 105 从前序与中序遍历序列构造二叉树

- [x] 106 从中序与后序遍历序列构造二叉树 

- [x] 124 二叉树中的最大路径和

- [x] 128 最长连续序列

- [x] 134 加油站

- [x] 136 只出现一次的数字 (异或)

- [x] 146 LRU缓存机制

- [x] 148 排序链表 (快排和归并) (高频) (*******)

- [x] 151 翻转字符串里的单词

- [x] 152 乘积最大子数组

- [x] 191 位1的个数

- [x] 206 反转链表 

- [x] 215 数组中的第K个最大元素 (堆排序和快速选择算法)

- [x] 217 存在重复元素

- [x] 226 翻转二叉树

- [x] 236 二叉树的最近公共祖先

- [x] 252 会议室

- [x] 279 完全平方数

- [x] 295 数据流的中位数

- [x] 300 最长上升子序列

- [x] 344 反转字符串

- [x] 543 二叉树的直径

- [x] 560 和为K的子数组 (*******)

- [x] 581 最短无序连续子数组

- [x] 739 每日温度（直接输出数值）

- [ ] 871 最低加油次数

- [x] 912 排序数组（快排，堆排，归并）

- [x] 1143 最长公共子序列

- [x] 面试题16.05 阶乘尾数

- [x] 面试题18 删除链表的节点

- [x] 面试题22 链表中倒数第k个节点

- [ ] TOP 面试题

- [x] 二叉树的遍历算法

- [x] KMP




---

1. 字符串中无重复最长字串的长度
2. 判断平衡二叉树非递归实现
3. 接雨水
4. 回文链表
5. 最小栈
6. 合并k个有序链表
7. 打家劫舍
8. 买卖股票
9. 俩数之和
10. 快排

----

## **7月中字节面试手撕代码统计数据**

### **后端**  

| 题目                                | 考察次数 |
| ----------------------------------- | -------- |
| 25. K 个一组翻转链表                | 4        |
| 121.买卖股票                        | 4        |
| 15. 三数之和                        | 3        |
| 155. 最小栈                         | 3        |
| 124. 二叉树中的最大路径和           | 3        |
| 199.二叉树的右视图                  | 3        |
| 3. 无重复字符的最长子串             | 3        |
| 88. 合并两个有序数组                | 3        |
| 108. 将有序数组转换为二叉搜索树     | 3        |
| 110. 平衡二叉树                     | 3        |
| 236. 二叉树的最近公共祖先           | 3        |
| 33. 搜索旋转排序数组                | 3        |
| 322. 零钱兑换                       | 3        |
| 83. 删除排序链表中的重复元素        | 2        |
| 206. 反转链表                       | 2        |
| 215. 数组中的第K个最大元素          | 2        |
| 56. 合并区间                        | 2        |
| 146. LRU缓存机制                    | 2        |
| 102. 二叉树的层序遍历               | 1        |
| 518. 零钱兑换 II                    | 1        |
| 剑指 Offer 09. 用两个栈实现队列     | 1        |
| 54. 螺旋矩阵                        | 1        |
| 1299.将每个元素替换为右侧最大元素   | 1        |
| 42.接雨水                           | 1        |
| 105. 从前序与中序遍历序列构造二叉树 | 1        |
| 160. 相交链表                       | 1        |
| 139 单词拆分                        | 1        |
| 67. 二进制求和                      | 1        |
| 230.二叉搜索树中第K小的元素         | 1        |
| 70. 爬楼梯                          | 1        |
| 剑指 Offer 61. 扑克牌中的顺子       | 1        |
| 543. 二叉树的直径                   | 1        |
| 112. 路径总和                       | 1        |
| 23. 合并K个排序链表                 | 1        |
| 1143. 最长公共子序列                | 1        |
| 2. 两数相加                         | 1        |
| 3无重复的最长字符串长度             | 1        |
| 141. 环形链表                       | 1        |
| 515. 在每个树行中找最大值           | 1        |
| 31. 下一个排列                      | 1        |
| 503. 下一个更大元素 II              | 1        |
| 297. 二叉树的序列化与反序列化       | 1        |
| 162. 寻找峰值                       | 1        |
| 221. 最大正方形                     | 1        |
| 128. 最长连续序列                   | 1        |
| 560. 和为K的子数组                  | 1        |
| 415.字符串相加                      | 1        |
| 328. 奇偶链表                       | 1        |
| 695. 岛屿的最大面积                 | 1        |
| 22. 括号生成                        | 1        |
| 32. 最长有效括号                    | 1        |

###   **客户端**  

| 题目                                          | 考察次数 |
| --------------------------------------------- | -------- |
| 206. 反转链表                                 | 4        |
| 144. 二叉树的前序遍历                         | 4        |
| 236. 二叉树的最近公共祖先                     | 3        |
| 25. K 个一组翻转链表                          | 3        |
| 121.买卖股票                                  | 3        |
| 53. 最大子序和                                | 3        |
| 94. 二叉树的中序遍历                          | 2        |
| 145. 二叉树的后序遍历                         | 2        |
| 33. 搜索旋转排序数组                          | 2        |
| 226. 翻转二叉树                               | 2        |
| 21. 合并两个有序链表                          | 2        |
| 215. 数组中的第K个最大元素                    | 2        |
| 剑指 Offer 09. 用两个栈实现队列               | 2        |
| 190. 颠倒二进制位                             | 2        |
| 300. 最长上升子序列                           | 1        |
| 199. 二叉树的右视图                           | 1        |
| 113. 路径总和 II                              | 1        |
| 136. 只出现一次的数字                         | 1        |
| 480.中位数                                    | 1        |
| 15.三数之和                                   | 1        |
| 543. 二叉树的直径                             | 1        |
| 234. 回文链表                                 | 1        |
| 160. 相交链表                                 | 1        |
| 23. 合并K个排序链表                           | 1        |
| 86. 分隔链表                                  | 1        |
| 剑指 Offer 36. 二叉搜索树与双向链表           | 1        |
| 142. 环形链表 II                              | 1        |
| 240. 搜索二维矩阵 II                          | 1        |
| 199.二叉树的右视图                            | 1        |
| 283. 移动零                                   | 1        |
| 102. 二叉树的层序遍历                         | 1        |
| 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 | 1        |
| 104. 二叉树的最大深度                         | 1        |
| 140. 单词拆分 II                              | 1        |
| 3. 无重复字符的最长子串                       | 1        |
| 122. 买卖股票的最佳时机 II                    | 1        |
| 460. LFU缓存                                  | 1        |
| 394. 字符串解码                               | 3        |
| 162. 寻找峰值                                 | 1        |

###   **前端**  

| 题目                        | 考察次数 |
| --------------------------- | -------- |
| 209. 长度最小的子数组       | 4        |
| 93. 复原IP地址              | 2        |
| 215. 数组中的第K个最大元素  | 2        |
| 226. 翻转二叉树             | 2        |
| 94. 二叉树的中序遍历        | 2        |
| 322. 零钱兑换               | 1        |
| 129. 求根到叶子节点数字之和 | 1        |
| 88. 合并两个有序数组        | 1        |
| 121.买卖股票                | 1        |
| 124. 二叉树中的最大路径和   | 1        |
| 104. 二叉树的最大深度       | 1        |

###   **算法**  

| 题目                          | 考察次数 |
| ----------------------------- | -------- |
| 160. 相交链表                 | 1        |
| 215. 数组中的第K个最大元素    | 1        |
| 33. 搜索旋转排序数组          | 1        |
| 200. 岛屿数量                 | 1        |
| 636. 函数的独占时间           | 1        |
| 103. 二叉树的锯齿形层次遍历   | 1        |
| 297. 二叉树的序列化与反序列化 | 1        |
| 3. 无重复字符的最长子串       | 1        |
| 572. 另一个树的子树           | 1        |

###   **测试**  

| 题目                                          | 考察次数 |
| --------------------------------------------- | -------- |
| 179. 最大数                                   | 2        |
| 1.两数之和                                    | 2        |
| 15. 三数之和                                  | 2        |
| 3. 无重复字符的最长子串                       | 1        |
| 160. 相交链表                                 | 1        |
| 剑指 Offer 39. 数组中出现次数超过一半的数字   | 1        |
| 20. 有效的括号                                | 1        |
| 236. 二叉树的最近公共祖先                     | 1        |
| 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 | 1        |
| 25. K 个一组翻转链表                          | 1        |
| 110. 平衡二叉树                               | 1        |
| 146. LRU缓存机制                              | 1        |
| 19. 删除链表的倒数第N个节点                   | 1        |
| 9. 回文数                                     | 1        |
| 405. 数字转换为十六进制数                     | 1        |
| 206. 反转链表                                 | 1        |
| 200. 岛屿数量                                 | 1        |



### 题目解析

#### 50.Pow(x, n)

```java
class Solution {
    public double myPow(double x, int n) {
        if (n == 0 || x == 1.0) {
            return 1;
        }
        long exp = n;
        double temp = x;
        if (n < 0) {
            exp = -exp;
            temp = 1 / temp;
        }
        double ans = 1.0;
        while (exp != 0) {
            if ((exp & 1) == 1) {
                ans *= temp;
            }
            temp *= temp;
            exp >>= 1;
        }
        return ans;
    }
}
```

#### 25.K 个一组翻转链表

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (k == 0) {
            return head;
        }

        ListNode tail = head;
        for (int i = 0; i < k; i++) {
            if (tail == null) {
                return head;
            }
            tail = tail.next;
        }
        ListNode newHead = reverseGroup(head, k);
        head.next = reverseKGroup(tail, k);
        return newHead;
    }

    public ListNode reverseGroup(ListNode head, int k) {
        ListNode curr = head;
        ListNode prev = null;
        ListNode next = head.next;
        while (curr != null && k-- > 0) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}
```

#### 121.买卖股票

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }
        int ans = 0;
        int minPrice = prices[0];
        for (int i = 0; i < prices.length; i++) {
            if (minPrice > prices[i]) {
                minPrice = prices[i];
            }
            ans = Math.max(ans, prices[i] - minPrice);
        }
        return ans;
    }
}
```

#### 15.三数之和

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length < 0) {
            return new ArrayList<>();
        }
        Arrays.sort(nums);
        int length = nums.length;
        for (int i = 0; i < nums.length - 2; i++) {
            int temp = nums[i];
            if (temp > 0) {
                break;
            }
            if (i != 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int start = i + 1;
            int end = nums.length - 1;
            while (start < end) {
                int sum = temp + nums[start] + nums[end];
                if (sum == 0) {
                    ans.add(Arrays.asList(temp, nums[start], nums[end]));
                    while(start < end && nums[start + 1] == nums[start]) {
                        start++;
                    }
                    while(start < end && nums[end - 1] == nums[end]) {
                        end--;
                    }
                    start++;
                    end--;
                } else if (sum > 0) {
                    end--;
                } else {
                    start++;
                }
            }
        }
        return ans;
    }
}
```

#### 155.最小栈

```java
class MinStack {
    LinkedList<Integer> stack;
    LinkedList<Integer> minValue;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new LinkedList<>();
        minValue = new LinkedList<>();
    }
    
    public void push(int x) {
        stack.offerLast(x);
        if (minValue.isEmpty() || minValue.peekLast() >= x) {
            minValue.offerLast(x);
        }
    }
    
    public void pop() {
        if (minValue.peekLast().equals(stack.peekLast())) {
            minValue.pollLast();
        }
        stack.pollLast();
    }
    
    public int top() {
        return stack.peekLast(); 
    }
    
    public int getMin() {
        return minValue.peekLast();
    }
}
```

#### 124.二叉树中的最大路径和

```java
class Solution {
    int ans = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        if (root == null) {
            return 0;
        }

        maxSum(root);

        return ans;
    }

    public int maxSum(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int leftValue = Math.max(0, maxSum(root.left));
        int rightValue = Math.max(0, maxSum(root.right));

        ans = Math.max(ans, root.val + leftValue + rightValue);
        return Math.max(leftValue, rightValue) + root.val;
    }
}
```



#### 3.无重复字符的最长子串

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int length = s.length();
        int[] index = new int[256];
        for (int i = 0; i < 256; i++) {
            index[i] = -1;
        }
        int ans = 0;
        int left = 0;
        for (int i = 0; i < length; i++) {
            char a = s.charAt(i);
            if (index[a] != -1) {
                left = Math.max(left, index[a] + 1);
            }
            ans = Math.max(ans, i - left + 1);
            index[a] = i;
        }
        return ans;
    }
}
```

#### 199.二叉树的右视图

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        if (root == null) {
            return new LinkedList<>();
        }
        LinkedList<Integer> ans = new LinkedList<>();
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            for (int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                if (i == 1) {
                    ans.offer(node.val);
                }
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }
        return ans;
    }
}
```

#### 88.合并两个有序数组

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int indexMerge = m + n - 1;
        int index1 = m - 1;
        int index2 = n - 1;
        while (index1 >= 0 || index2 >= 0) {
            if (index1 == -1) {
                nums1[indexMerge] = nums2[index2];
                index2--;
            } 
            else if (index2 == -1) {
                nums1[indexMerge] = nums1[index1];
                index1--;
            }
            else if (nums1[index1] > nums2[index2]) {
                nums1[indexMerge] = nums1[index1];
                index1--;
            } else {
                nums1[indexMerge] = nums2[index2];
                index2--;
            }
            indexMerge--;
        }
    }
}
```

#### 108.将有序数组转换为二叉搜索树

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if (nums == null || nums.length == 0) {
            return null;
        }
        int length = nums.length;
        return buildTree(nums, 0, length - 1);
    }

    public TreeNode buildTree(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        if (left == right) {
            return new TreeNode(nums[left]);
        }
        int mid = left + ((right - left) >> 1);
        TreeNode root = new TreeNode(nums[mid]);
        root.left = buildTree(nums, left, mid - 1);
        root.right = buildTree(nums, mid + 1, right);
        return root;
    }
}
```



#### 110.平衡二叉树

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return getHeight(root) >= 0;
    }

    public int getHeight(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        int rightHeight = getHeight(root.right);
        int difference = leftHeight - rightHeight;
        if (leftHeight < 0 || rightHeight < 0 || difference > 1 || difference < -1){
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

#### 236.二叉树的最近公共祖先

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == p || root == q || root == null) {
            return root;
        } 
        TreeNode left = lowestCommonAncestor(root.left, p, q); 
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if (left != null && right != null) {
            return root;
        } 
        return left != null ? left : right;
    }
}
```

#### 33.搜索旋转排序数组

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return mid;
            }
            
            if (nums[left] <= nums[mid]) {
                if (target < nums[mid] && target >= nums[left]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

#### 322.零钱兑换

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int[] dp = new int[amount + 1];
        for (int i = 1; i < amount + 1; i++) {
            dp[i] = amount + 1;
            for (int j = 0; j < coins.length; j++) {
                if (i - coins[j] < 0) {
                    break;
                }
                dp[i] = Math.min(dp[i - coins[j]] + 1, dp[i]);
            }
        }
        return dp[amount] == amount + 1 ? -1 : dp[amount]; 
    }

}
```

#### 518.零钱兑换 II

```java
class Solution {
    public int change(int amount, int[] coins) {
        int len = coins.length;
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for(int i = 1; i <= len; i++){
            for(int j = coins[i - 1]; j <= amount; j++){
                dp[j] += dp[j - coins[i - 1]];
            }
        }
        return dp[amount];
    }
}
```

#### 83.删除排序链表中的重复元素

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode temp = head;
        while (temp.next != null) {
            if (temp.next.val == temp.val) {
                temp.next = temp.next.next;
            } else {
                temp = temp.next;
            }
        }
        return head;
    }
}
```

#### 206.反转链表

```jav
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head == null){
            return null;
        }
        ListNode curr = head;
        ListNode prev = null;
        while(curr != null){
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}
```

#### 215.数组中的第K个最大元素

```java
class Solution {
    Random random = new Random();
    public int findKthLargest(int[] nums, int k) {
        quickSort(nums, 0, nums.length - 1, k);
        return nums[k - 1];
    }

    public void quickSort(int[] nums, int left, int right, int k) {
        if (left >= right) {
            return;
        }
        int index = left + random.nextInt(right - left + 1);
        int pivot = nums[index];
        swap(nums, index, right);
        int i, j;
        for (i = left, j = left; i < right; i++) {
            if (nums[i] > pivot) {
                swap(nums, i, j);
                j++;
            } 
        }
        swap(nums, j, right);
        if (j == k - 1) {
            return;
        }
        else if (j > k - 1) {
            quickSort(nums, left, j - 1, k);
        } else {
            quickSort(nums, j + 1, right, k);
        }
    } 

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> minQueue = new PriorityQueue<>();
        for(int num : nums){
            if (minQueue.size() < k) {
                minQueue.add(num);
            } else if (minQueue.peek() < num) {
                minQueue.poll();
                minQueue.add(num);
            }

        }
        return minQueue.peek();
    }
}
```

#### 56.合并区间

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals == null || intervals.length == 1) {
            return intervals;
        }
        List<int[]> newIntervals = new ArrayList<>();
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        int i = 0;
        int n = intervals.length;
        while (i < n) {
            int left = intervals[i][0];
            int right = intervals[i][1];
            while (i < n - 1 && right >= intervals[i + 1][0]) {
                right = Math.max(right, intervals[i + 1][1]);
                i++;
            }
            newIntervals.add(new int[]{left, right});
            i++;
        }
        return newIntervals.toArray(new int[newIntervals.size()][2]);
    }
}
```

#### 102.二叉树的层序遍历

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) {
            return new ArrayList<>();
        }
        List<List<Integer>> ans = new LinkedList<>();
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while(!q.isEmpty()) {
            LinkedList<Integer> levelAns = new LinkedList<>();
            for(int i = q.size(); i > 0; i--) {
                TreeNode cur = q.poll();
                levelAns.add(cur.val);
                if(cur.left != null) {
                    q.offer(cur.left);
                }
                if(cur.right != null) {
                    q.offer(cur.right);
                }
            }
            ans.add(levelAns);
        }
        
        return ans;
    }
}
```

####   1299.将每个元素替换为右侧最大元素

```java
class Solution {
    public int[] replaceElements(int[] arr) {
        int maxValue = -1;
        for (int i = arr.length - 1; i >= 0; i--) {
            int temp = arr[i];
            arr[i] = maxValue;
            maxValue = Math.max(maxValue, temp);
        }
        return arr;
    }
}
```

#### 42.接雨水

```java
class Solution {
    public int trap(int[] heights) {
        if (heights == null || heights.length == 0) {
            return 0;
        }
        LinkedList<Integer> stack = new LinkedList<>();
        int count = 0;
        for (int i = 0; i < heights.length; i++) {
            while (!stack.isEmpty() && heights[stack.peekLast()] < heights[i]) {
                int bottom = heights[stack.pollLast()];
                while (!stack.isEmpty() && heights[stack.peekLast()] == bottom) {
                    stack.pollLast();
                }
                if (!stack.isEmpty()) {
                    int height = Math.min(heights[i], heights[stack.peekLast()]) - bottom;
                    int width = i - stack.peekLast() - 1;
                    count += height * width;
                }
            }

            stack.offerLast(i);
        }
        return count;
    }
}
```

#### 160.相交链表

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        int lengthA = 0;
        int lengthB = 0;
        ListNode tempA = headA;
        ListNode tempB = headB;
        while (tempA != null) {
            tempA = tempA.next;
            lengthA++;
        }
        
        while (tempB != null) {
            tempB = tempB.next;
            lengthB++;
        }

        if (lengthA == 0 || lengthB == 0) {
            return null;
        }

        if (lengthA > lengthB) {
            int step = lengthA - lengthB;
            while (step-- > 0) {
                headA = headA.next;
            }
        } else if (lengthB > lengthA) {
            int step = lengthB - lengthA;
            while (step-- > 0) {
                headB = headB.next;
            }
        }
        while (headA !=null && headA != headB) {
            headA = headA.next;
            headB = headB.next;
        }
        return headA;
    }
}
```

#### 105.从前序与中序遍历序列构造二叉树

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return constructBinaryTree(preorder, inorder, 0, 0, inorder.length - 1) ;
    }

    public TreeNode constructBinaryTree(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd) {
        if (inStart > inEnd) {
            return null;
        }
        
        TreeNode root = new TreeNode(preorder[preStart]);
        int mid = inStart;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == preorder[preStart]) {
                mid = i;
            }
        }
        root.left = constructBinaryTree(preorder, inorder, preStart + 1, inStart, mid - 1);
        root.right = constructBinaryTree(preorder, inorder, preStart + mid - inStart + 1, mid + 1, inEnd);
        return root;
    }
}
```

#### 67.二进制求和

```java
class Solution {
    public String addBinary(String a, String b) {
        int lengthA = a.length();
        int lengthB = b.length();
        StringBuilder ans = new StringBuilder();
        int indexA = lengthA - 1;
        int indexB = lengthB - 1;
        int carry = 0;
        while (indexA >= 0 && indexB >= 0) {
            int sum = a.charAt(indexA) - '0' + b.charAt(indexB) - '0' + carry;
            carry =  sum >= 2 ? 1 : 0;
            char cur = sum == 1 || sum == 3 ? '1' : '0';
            ans.append(cur);
            indexA--;
            indexB--;
        }
        if (indexA >= 0) {
            while(indexA >= 0) {
                int sum = a.charAt(indexA) - '0' + carry;
                carry =  sum == 2 ? 1 : 0;
                char cur = sum == 1 ? '1' : '0';
                ans.append(cur);
                indexA--;
            }
        } else if (indexB >= 0) {
            while(indexB >= 0) {
                int sum = b.charAt(indexB) - '0' + carry;
                carry =  sum == 2 ? 1 : 0;
                char cur = sum == 1 ? '1' : '0';
                ans.append(cur);
                indexB--;
            }
        }
        if (carry == 1) {
            ans.append('1');
        }
        return ans.reverse().toString();
    }
}
```

#### 112.路径总和

```java
class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root == null) {
            return false;
        }
        int next = sum - root.val;
        if (root.left == null && root.right == null) {
            return next == 0;
        }
        return hasPathSum(root.left, next) || hasPathSum(root.right, next);
    }
}
```

#### 23. 合并K个排序链表

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode head = new ListNode(-1);
        ListNode temp = head;
        PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
            @Override
            public int compare(ListNode a, ListNode b) {
                return a.val - b.val;
            }
        });
        for (int i = 0; i < lists.length; i++) {
            if (lists[i] == null) {
                continue;
            }
            pq.offer(lists[i]);
        }
        while (!pq.isEmpty()) {
            ListNode cur = pq.poll();
            temp.next = cur;
            temp = temp.next;
            if (cur.next != null) {
                pq.offer(cur.next);
            }
        }
        return head.next;
    }
}
```



#### 21.合并两个有序链表

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode cur = head;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 == null) {
            cur.next = l2;
        } else {
            cur.next = l1;
        }
        return head.next;
    }
}
```

#### 2. 两数相加

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(0);
        ListNode temp = head;
        int carry = 0;
        while (l1 != null && l2 != null) {
            int sum  = l1.val + l2.val + carry;
            carry = sum / 10;
            temp.next = new ListNode(sum % 10);
            l1 = l1.next;
            l2 = l2.next;
            temp = temp.next;
        } 
        while (l1 != null) {
            int sum = l1.val + carry;
            carry = sum / 10;
            temp.next = new ListNode(sum % 10);
            l1 = l1.next;
            temp = temp.next;
        }
        
        while (l2 != null) {
            int sum = l2.val + carry;
            carry = sum / 10;
            temp.next = new ListNode(sum % 10);
            l2 = l2.next;
            temp = temp.next;
        }
        
        if (carry != 0) {
            temp.next = new ListNode(carry);
        }
        return head.next;
    }
}
```

#### 148.排序链表

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode fastP = head.next;
        ListNode slowP = head;
        while (fastP != null && fastP.next != null) {
            fastP = fastP.next.next;
            slowP = slowP.next;
        }
        ListNode a = sortList(slowP.next);
        slowP.next = null;
        ListNode b = sortList(head);
        return mergeList(a, b);
    }

    private ListNode mergeList(ListNode a, ListNode b) {
        ListNode head = new ListNode(-1);
        ListNode temp = head;
        while (a != null && b != null) {
            if (a.val <= b.val) {
                temp.next = a;
                a = a.next;
            } else {
                temp.next = b;
                b = b.next;
            }
            temp = temp.next;
        }
        if (a != null) {
            temp.next = a;
        }
        if (b != null) {
            temp.next = b;
        }
        return head.next;
    }
}
```

#### 160. 相交链表 

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode fast = head, slow = head;
        boolean flag = false;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                flag = true;
                break;
            }
        }
        if (flag) {
            fast = head;
            while (fast != slow) {
                fast = fast.next;
                slow = slow.next;
            }
            return fast;
        } else {
            return null;
        }
    }
}
```

#### 103. 二叉树的锯齿形层次遍历

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> ans = new LinkedList<>();
        if (root == null) {
            return ans;
        }
        boolean isOddLevel = true;
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offerLast(root);
        while (!queue.isEmpty()) {
            LinkedList<Integer> subAns = new LinkedList<>();
            for (int i = queue.size(); i > 0; i--) {
                TreeNode cur;
                if (isOddLevel) {
                    cur = queue.pollFirst();
                } else {
                    cur = queue.pollLast();
                }
                subAns.offer(cur.val);
                if (isOddLevel) {
                    if (cur.left != null) {
                        queue.offerLast(cur.left);
                    }
                    if (cur.right != null) {
                        queue.offerLast(cur.right);
                    }
                } else {
                    if (cur.right != null) {
                        queue.offerFirst(cur.right);
                    }
                    if (cur.left != null) {
                        queue.offerFirst(cur.left);
                    }
                }
            }
            ans.add(subAns);
            isOddLevel = !isOddLevel;
        }
        return ans;
    }
}
```

#### 221. 最大正方形

```java
public int maximalSquare2(char[][] matrix) {
        /**
         * dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长。
         * 如果该位置的值是 0，则 dp(i,j) = 0，因为当前位置不可能在由 1 组成的正方形中；
         * 如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1；
         * 则递推式为:
         * dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
         **/
        int m = matrix.length;
        if (m < 1) {
            return 0;
        }
        int n = matrix[0].length;
        int max = 0;
        int[][] dp = new int[m+1][n+1];

        for(int i = 1; i <= m; ++i) {
            for(int j = 1; j <= n; ++j) {
                if(matrix[i-1][j-1] == '1') {
                    dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                    max = Math.max(max, dp[i][j]);
                }
            }
        }

        return max * max;
    }
```

#### 76. 最小覆盖子串

```java
class Solution {
    public String minWindow(String s, String t) {
        int[] mp = new int[256];
        for (char c : t.toCharArray()) {
            mp[c]++;
        }
        int n = s.length();
        int m = t.length();
        int start = 0, end = 0;
        int cnt = 0;
        int res = -1;
        String ans = "";
        while (end < n) {
            char a = s.charAt(end);
            if (mp[a] >= 1) {
                cnt++;
            }
            mp[a]--;
            while (cnt == m) {
                if (res == -1 || res > end - start + 1) {
                    ans = s.substring(start, end + 1);
                    res = end - start + 1;
                }
                char c = s.charAt(start);
                mp[c]++;
                if (mp[c] >= 1) {
                    cnt--;
                }
                start++;
            } 
            end++;
        }
        return ans;
    }
}
```

#### 53. 最大子序和

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int ans = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = dp[i - 1] < 0 ? nums[i] : dp[i - 1] + nums[i];
            ans = Math.max(dp[i], ans);
        }
        return ans;
    }
}
```

#### 739. 每日温度

```java
class Solution {
    public int[] dailyTemperatures(int[] T) {
        if (T == null || T.length == 0) {
            return new int[0];
        } 
        LinkedList<Integer> stack = new LinkedList<>();
        int length = T.length;
        int[] ans = new int[length];
        stack.push(0);
        for (int i = 1; i < length; i++) {
            while (!stack.isEmpty() && T[i] > T[stack.peek()]) {
                int index = stack.poll();
                ans[index] = i - index;
            }
            stack.push(i);
        }
        while (!stack.isEmpty()) {
            ans[stack.poll()] = 0;
        }
        return ans;
    }
}
```

#### 31. 下一个排列

```java
判断按照字典序有木有下一个，如果完全降序就没有下一个
    
如何判断有木有下一个呢？只要存在a[i-1] < a[i]的升序结构，就有，而且我们应该从右往左找，一旦找到，因为这样才是真正下一个
当发现a[i-1] < a[i]的结构时，从在[i, ∞]中找到最接近a[i-1]并且又大于a[i-1]的数字，由于降序，从右往左遍历即可得到k
然后交换a[i-1]与a[k]，然后对[i, ∞]排序即可，排序只需要首尾不停交换即可，因为已经是降序 上面说的很抽象，还是需要拿一些例子思考才行，比如[0,5,4,3,2,1]，下一个是[1,0,2,3,4,5]

class Solution {
    public void nextPermutation(int[] nums) {
        if (nums == null || nums.length <= 1) {
            return;
        }
        int len = nums.length;
        for (int i = len - 2; i >= 0; i--) {
            if (nums[i] < nums[i + 1]) {
                int index = i + 1;
                for (int j = i + 1; j < len; j++) {
                    if (nums[index] > nums[j] && nums[j] > nums[i]) {
                        index = j;
                    }
                }

                swap(nums, i, index);
                Arrays.sort(nums, i + 1, len);
                return;
            }
        }
        reverse(nums, 0, len - 1);
    }

    public void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

#### 128. 最长连续序列

```java
给定一个未排序的整数数组，找出最长连续序列的长度。
class Solution {
    public int longestConsecutive(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        Set<Integer> numSet = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            numSet.add(nums[i]);
        }
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            if (numSet.contains(num)) {
                int count = 1;
                int left = num - 1;
                int right = num + 1;
                numSet.remove(num);
                while (numSet.contains(left)) {
                    numSet.remove(left);
                    left--;
                    count++;
                } 
                while (numSet.contains(right)) {
                    numSet.remove(right);
                    right++;
                    count++;
                }
                ans = Math.max(ans, count);
            }  
        }
        return ans;

    }
}
```

#### 253. 会议室2

```java
//leetcode 252 253 算是贪心算法中比较重要的了
public static boolean isInterval(int[][] intervals){
        if (intervals.length == 0) {
            return true;
        }
        int length = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        int end = intervals[0][1];
        for (int i = 1; i < length; i++) {
            if (end > intervals[i][0]) {
                return false;
            }
            end = Math.min(end, intervals[i][1]);
        }
        return true;
    }

    public static int isInterval2(int[][] intervals){
        if (intervals.length == 0) {
            return 0;
        }
        int length = intervals.length;
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        int count = 1;
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        queue.offer(intervals[0][1]);
        for (int i = 1; i < length; i++) {
            if (!queue.isEmpty() && intervals[i][0] >= queue.peek()) {
                queue.poll();
            }
            queue.offer(intervals[i][1]);
        }
        return queue.size();
    }
}
```

#### 主函数

```java
import java.text.DecimalFormat;
import java.util.*;	
public class Main {
	public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            String string = sc.next();
        }

        Scanner sc2 = new Scanner(System.in);
        int n2 = sc2.nextInt();
        int[] arr = new int[n2];
        for (int i = 0; i < n2; i++) {
            arr[i] = sc2.nextInt();
        }
        
        String str = sc.nextLine();

        Scanner sc3 = new Scanner(System.in);
        int n3 = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();

        int a[] = new int[n3];

        int ans = 0;

        PriorityQueue<int[]> que1 = new PriorityQueue<int[]>((a1,a2)->{
            if(a1[0]!=a2[0]){
                return a2[0]-a1[0];
            }
            else{
                return a1[1]-a2[1];
            }
        });
        
        
        PriorityQueue<Integer> heap = new PriorityQueue<>((a12, b) -> b - a12);

        Integer[] arr2 = new Integer[20];
        Arrays.sort(arr2, (o1, o2) -> o1 - o2);
        
        Arrays.sort(arr2, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });

        double res = 0.0;
        DecimalFormat df = new DecimalFormat("#0.000000");
        System.out.println(df.format(res));

        List<Integer> c = new LinkedList<Integer>();

    }
}
```

